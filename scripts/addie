#!/usr/bin/env python
from __future__ import (absolute_import, division, print_function)

import copy
import sys
import numpy as np
import os
import itertools
import psutil
from collections import OrderedDict

# must be imported through qtpy before any other gui imports
from qtpy.QtCore import (QProcess, Qt, QUrl)
from qtpy.QtGui import (QDesktopServices, QIcon)
from qtpy import QtGui
from qtpy.QtWidgets import (QApplication, QFileDialog, QMainWindow, QMessageBox, QTableWidgetItem, QVBoxLayout, QWidget)

from addie import __version__
from addie.initialization.widgets.configuration import ConfigurationInitializer
from addie.utilities.general import get_ucams
from addie.utilities import load_ui

from addie.about import AboutDialog
from addie.menu.file.settings.advanced_file_window import AdvancedWindowLauncher
from addie.menu.file.configuration.export_configuration import ExportConfiguration
from addie.menu.file.configuration.import_configuration import ImportConfiguration

from addie.help_handler.help_gui import HelpGui, help_button_activator

from addie.utilities.job_status_handler import JobStatusHandler
from addie.utilities.job_monitor_thread import JobMonitorThread
from addie.utilities.logbook_thread import LogbookThread
from addie.utilities.logbook_handler import LogbookHandler
from addie.utilities.ipts_file_transfer_dialog import IptsFileTransferDialog

from addie.initialization.widgets.init_step1 import InitStep1

from addie.autoNOM.step1_gui_handler import Step1GuiHandler
from addie.autoNOM.run_step1 import RunStep1
from addie.processing.idl.load_table_intermediate_step_interface import loadTableIntermediateStepInterface
from addie.processing.idl.undo_handler import UndoHandler

from addie.initialization.widgets.init_step2 import InitStep2
from addie.processing.idl.populate_master_table import PopulateMasterTable
from addie.processing.idl.populate_background_widgets import PopulateBackgroundWidgets
from addie.processing.idl.step2_gui_handler import Step2GuiHandler
from addie.processing.idl.table_handler import TableHandler as IdlTableHandler
from addie.processing.idl.create_sample_files import CreateSampleFiles
from addie.processing.idl.create_ndsum_file import CreateNdsumFile
from addie.processing.idl.run_ndabs import RunNDabs
from addie.processing.idl.run_sum_scans import RunSumScans
from addie.processing.idl.run_thread import RunThread

from addie.menu.preview_ascii.step3_gui_handler import Step3GuiHandler

from addie.mantid_handler.browse_file_folder_handler import BrowseFileFolderHandler
from addie.mantid_handler.mantid_reduction import GlobalMantidReduction
from addie.mantid_handler.mantid_thread import MantidThread

from addie.processing.mantid.master_table.master_table_loader import FromDictionaryToTableUi, AsciiLoader
from addie.processing.mantid.master_table.table_tree_handler import TableTreeHandler, TableInitialization, \
    TableConfig, H3TableHandler
from addie.processing.mantid.master_table.table_tree_handler import SaveConfigInterface, TableTree
from addie.processing.mantid.master_table import *
from addie.processing.mantid.master_table.table_row_handler import TableRowHandler
from addie.processing.mantid.master_table.geometry_handler import DimensionsSetter
from addie.processing.mantid.master_table.selection_handler import TableHandler as MtdTableHandler
from addie.processing.mantid.master_table.reduction_configuration_handler import ReductionConfigurationHandler
from addie.processing.mantid.make_calibration_handler.make_calibration import MakeCalibrationLauncher
from addie.processing.mantid.master_table.periodic_table.material_handler import MaterialHandler
from addie.processing.mantid.master_table.mass_density_handler import MassDensityHandler

try:
    from addie.processing.mantid.master_table.import_from_database.import_from_database_handler import ImportFromDatabaseHandler
    ONCAT_ENABLED = True
except ImportError:
    print('pyoncat module not found. Functionality disabled')
    ONCAT_ENABLED = False

from addie.processing.mantid.master_table.import_from_run_number_handler import ImportFromRunNumberHandler
from addie.processing.mantid.master_table.import_from_database.load_into_master_table import LoadIntoMasterTable

import addie.addiedriver as driver
# import addie.utilities.specify_plots_style as ps
import addie.calculate_gr.edit_sq_dialog

from addie.calculate_gr.pdf_lines_manager import PDFPlotManager
from mantidqt.widgets.jupyterconsole import InProcessJupyterConsole

from addie.processing.mantid.master_table.master_table_exporter import TableFileExporter as MantidTableExporter

from addie.rietveld.braggview import BraggView
from addie.rietveld.braggtree import BraggTree

from addie.icons import icons_rc

from addie.initialization.widgets import rietveld_tab as rietveld_tab_initialization
from addie.initialization.widgets import processing_tab as processing_tab_initialization
from addie.initialization.widgets import calculategr_tab as calculategr_tab_initialization

from addie.initialization.events import processing_tab as processing_tab_events_handler
from addie.initialization.events import rietveld_tab as rietveld_tab_events_handler
from addie.initialization.events import calculategr_tab as calculategr_tab_events_handler

from addie.rietveld import event_handler as rietveld_event_handler
from addie.calculate_gr import event_handler as calculategr_event_handler

DEBUG = False

IPYTHON_STARTUP_CODE = '''import numpy as np
from mantid.simpleapi import *
'''


class MainWindow(QMainWindow):
    """ Main addie window
    """

    first_oncat_authentication = True
    oncat = None # object to use to retrieve IPTS numbers...etc. Created by oncat_authentication_handler.py

    # config.json ======================================================
    # those infos will be automatically retrieve from the config.json file
    facility = ''
    instrument = {"full_name": "",   # Powgen, Nomad ...
                  "short_name": ""}  # PG3, NOM ...
    list_instrument = {"full_name": [],
                       "short_name": []}
    config_calibration_folder = {"pre": "", "post": ""}
    config_characterization_folder = {"pre": "", "post": ""}

    calibration_extension = ""
    characterization_extension = ""

    cache_folder = './' # defined in the advanced window
    output_folder = './' # defined in the advanced window

    placzek_default = {}

    # list of arguments to use in Import from ONCat and to display for filters
    oncat_metadata_filters = []
    # end of config.json ======================================================

    # Master json created by master_table_loader_from_database where keys are "1-10,15,16" with list of json and
    # list of titles (used to fix conflicts when loading)
    # json_to_import = {'1,2,5-10': {'list_of_json': [json1, json2, json5, json6, json7, ... json10],
    #                                'title': "title_1_1,2,5-10'},
    #                   '20-30': {'list_of_json': [...',
    #                             'title': "title_20-30"},
    #                   ... }
    json_to_import = None

    # flag that will clear or not the master table before loading data
    clear_master_table_before_loading = True

    # load los.csv options
    ascii_loader_option = None   # None, 1, 2, 3, 4
    ascii_loader_dictionary = {}

    # intermediate and output grouping files
    grouping_dict = {'filename': "",
                     'nbr_groups': "N/A",
                     'enabled': False}
    intermediate_grouping = copy.deepcopy(grouping_dict)
    output_grouping = copy.deepcopy(grouping_dict)

    statusbar_display_time = 5000  # 5s

    # external ui (use to make sure there is only one open at a time
    import_from_database_ui = None
    import_from_database_ui_position = None

    import_from_run_number_ui = None
    import_from_run_number_ui_position = None

    oncat_authentication_ui_position = None

    conflicts_solver_ui_position = None

    advanced_window_ui = None
    make_calibration_ui = None
    make_calibration_ui_position = None
    table_tree_ui = None
    table_tree_ui_position = None
    placzek_ui = None
    reduction_configuration_ui = None
    reduction_configuration_ui_position = None

    material_ui = None
    material_ui_position = None

    mass_density_ui = None
    mass_density_ui_position = None

    geometry_ui_position = None

    # config file to initialize the widgets (example Q and R range in PDF tab)
    current_path = os.path.dirname(os.path.dirname(__file__))
    addie_config_file = os.path.join(os.path.dirname(addie.__file__),  "config.json")

    # master table reduction configuration
    reduction_configuration = {}

    # configuration of master table
    config_dict = OrderedDict()
    reset_config_dict = OrderedDict()
    active_config_name = ''
    list_config_displayed = []

    # will list the various ui for each row using a random number as key
    dict_widget = {'ui': None,
                   'status': False}
    master_table_right_click_buttons = {'activate': copy.deepcopy(dict_widget),
                                        'activate_check_all': copy.deepcopy(dict_widget),
                                        'activate_uncheck_all': copy.deepcopy(dict_widget),
                                        'activate_inverse': copy.deepcopy(dict_widget),
                                        'cells': copy.deepcopy(dict_widget),
                                        'cells_paste': copy.deepcopy(dict_widget),
                                        'cells_copy': copy.deepcopy(dict_widget),
                                        'cells_clear': copy.deepcopy(dict_widget),
                                        'rows_paste': copy.deepcopy(dict_widget),
                                        'rows_copy': copy.deepcopy(dict_widget),
                                        'rows_duplicate': copy.deepcopy(dict_widget),
                                        'rows_remove': copy.deepcopy(dict_widget),
                                        'reset': copy.deepcopy(dict_widget),
                                        'clear': copy.deepcopy(dict_widget),
                                        'import_from_config_append': copy.deepcopy(dict_widget),
                                        'import_from_file_append': copy.deepcopy(dict_widget),
                                        'import_from_database_append': copy.deepcopy(dict_widget),
                                        'export': copy.deepcopy(dict_widget),
                                        'plot': copy.deepcopy(dict_widget),
                                        }

    placzek_info_dict = {'order_text': None,
                         'order_index': None,
                         'is_self': None,
                         'is_interference': None,
                         'fit_spectrum_text': None,
                         'fit_spectrum_index': None,
                         'lambda_fit_min': None,
                         'lambda_fit_max': None,
                         'lambda_fit_delta': None,
                         'lambda_calc_min': None,
                         'lambda_calc_max': None,
                         'lambda_calc_delta': None,
                         }

    master_table_list_ui = OrderedDict()
    master_table_cells_copy = {'temp': [],
                               'list_column': [],
                               'row': [],
                               }

    table_headers = {'h1': [],
                     'h2': [],
                     'h3': [],
                     }

    table_width = {'h1': [],
                   'h2': [],
                   'h3': []}

    # to find which h1 column goes with wich h2 and which h3
    table_columns_links = {'h1': [],
                           'h2': [],
                           'h3': [],
                           }
    tree_dict = None
    tree_ui = None
    minimum_col_width = 10

    # headers from master table
    h1_header_table = None
    h2_header_table = None
    h3_header_table = None

    undo_table = {}
    max_undo_list = 10
    undo_index = max_undo_list
    undo_button_enabled = False
    redo_button_enabled = False

    debugging = False
    load_intermediate_step_ok = False
    remove_dynamic_temperature_flag = False
    current_folder = os.getcwd()
    configuration_folder = current_folder
    calibration_folder = ''
    characterization_folder = ''
    file_path = os.getcwd()
    table_selection_buffer = {}
    _run_thread_sum_scans = RunThread()
    advanced_window_idl_groupbox_visible = False

    logbook_thread = LogbookThread()
    number_of_last_log_files_to_display = 10
    previous_list_of_log_files = []

    _run_thread = RunThread()
    job_monitor_thread = JobMonitorThread()
    _mantid_thread_array = list(itertools.repeat(MantidThread(), 30))
    config_section_name = 'Configuration'
    job_monitor_interface = None
    logbook_interface = None
    job_list = []

    init_height_main_gui = 1058
    previous_splitter_height = -1
    first_time_resizing_blocked = True

    o_help_autonom = None
    o_help_ndabs = None
    o_help_scans = None
    o_help_mantid = None

    def __init__(self, parent=None, processing_mode=None):
        """ Initialization
        Parameters
        ----------
        """
        QMainWindow.__init__(self, parent)

        # Initialize the UI widgets
        self.ui = load_ui('mainWindow.ui', baseinstance=self)

        # Mantid processing tab
        self.processing_tab_widget = QWidget()
        self.processing_ui = load_ui('splitui_processing_tab.ui', baseinstance=self.processing_tab_widget)
        self.ui.main_tab.insertTab(2, self.processing_tab_widget, "Processing")
        processing_tab_initialization.run(main_window=self)

        # Rietveld  tab
        self.rietveld_tab_widget = QWidget()
        self.rietveld_ui = load_ui('splitui_rietveld_tab.ui', baseinstance=self.rietveld_tab_widget)
        self.ui.main_tab.insertTab(3, self.rietveld_tab_widget, "Rietveld")
        rietveld_tab_initialization.run(main_window=self)

        # Calculate G(R) tab
        self.calculategr_tab_widget = QWidget()
        self.calculategr_ui = load_ui('splitui_calculategr_tab.ui', baseinstance=self.calculategr_tab_widget)
        self.ui.main_tab.insertTab(4, self.calculategr_tab_widget, 'Calculate G(R)')
        calculategr_tab_initialization.run(main_window=self)

        self.init_parameters()
        self.set_default_folders_path()
        # Set the post-processing mode
        self.post_processing = processing_mode  # mantid or 'idl'

        self.ucams = get_ucams()

        #elf.ui.graphicsView_sq.set_main(self)

        self._promote_widgets()

        # set widgets
        self._init_widgets()
        InitStep1(parent=self)
        InitStep2(parent=self)
        #self.init_master_table()

        # define the event handling methods
        #self.ui.mantid_run_reduction.clicked.connect(self.do_mantid_run_reduction)

        # for tab G(R)
        # self.ui.pushButton_loadSQ.clicked.connect(self.do_load_sq)
        # self.ui.comboBox_SofQType.currentIndexChanged.connect(self.evt_change_sq_type)
        # self.ui.pushButton_clearSofQ.clicked.connect(self.do_clear_sq)
        # self.ui.pushButton_showQMinMax.clicked.connect(self.do_show_sq_bound)
        # self.ui.pushButton_generateGR.clicked.connect(self.do_generate_gr)
        # self.ui.pushButton_loadGofR.clicked.connect(self.do_load_gr)
        # self.ui.pushButton_saveGR.clicked.connect(self.do_save_gr)
        # self.ui.pushButton_clearGrCanvas.clicked.connect(self.do_clear_gr)
        # self.ui.pushButton_saveSQ.clicked.connect(self.do_save_sq)
        # self.ui.pushButton_editSofQ.clicked.connect(self.do_edit_sq)
        # self.ui.pushButton_generateSQ.clicked.connect(self.do_generate_sq)
        #
        # self.ui.doubleSpinBoxQmin.valueChanged.connect(self.evt_qmin_changed)
        # self.ui.doubleSpinBoxQmax.valueChanged.connect(self.evt_qmax_changed)
        #
        # self.ui.pushButton_rescaleSq.clicked.connect(self.do_rescale_sofq)
        # self.ui.pushButton_rescaleGr.clicked.connect(self.do_rescale_gofr)
        #
        # self.ui.pushButton_grColorStyle.clicked.connect(self.do_set_gofr_color_marker)
        # self.ui.pushButton_sqColorStyle.clicked.connect(self.do_set_sq_color_marker)

        # # #  menu operations
        # self.ui.actionReset_GofR_tab.triggered.connect(self.do_reset_gr_tab)
        # self.ui.actionReset_GSAS_tab.triggered.connect(self.do_reset_gsas_tab)

        self.ui.actionQuit.triggered.connect(self.evt_quit)
        self.ui.actionCheat_sheet.triggered.connect(self.do_show_help)

        # define the driver
        self._myController = driver.AddieDriver()

        # class variable for easy access
        self._gssGroupName = None
        self._currDataDir = None
        self._inFixedDirectoryStructure = False
        self._currWorkDir = os.getcwd()

        # mutex-like variables
        self._noEventBankWidgets = False

        # help (refer to DGSPlanner and HFIR Powder reduction GUI)
        self._assistantProcess = QProcess(self)

        # a collection of sub window
        self._editSqDialog = None
        self._editedSofQDict = dict()

        # color management
        self._pdfColorManager = PDFPlotManager()

        #self.save_raw_config()

        if DEBUG:
            o_row = TableRowHandler(parent=self)
            for _row in np.arange(10):
                o_row.insert_row(row=_row)

        # Connecting all the widgets
        processing_tab_events_handler.run(main_window=self)
        rietveld_tab_events_handler.run(main_window=self)
        calculategr_tab_events_handler.run(main_window=self)

        # # set the tab to 0
        # main_window.calculategr_ui.main_tab.setCurrentIndex(0)

    def save_raw_config(self):
        '''this will allow the user to reset the full table and get it back in its initial state'''
        o_current_table_config = TableConfig(main_window=self)
        current_config = o_current_table_config.get_current_config()

        inside_dict = OrderedDict()
        inside_dict['table'] = current_config
        inside_dict['active'] = False

        self.reset_config_dict = inside_dict

    def init_parameters(self):
        ConfigurationInitializer(parent=self)

    def set_default_folders_path(self):
        '''Where the calibration_folder and characterization folder will be initialized
        using instrument name...

        this is very important when the instrument changed
        '''
        instrument_short_name = self.instrument["short_name"]
        config_calibration_folder = self.config_calibration_folder

        self.calibration_folder = os.path.join(config_calibration_folder["pre"],
                                               instrument_short_name,
                                               config_calibration_folder["post"])

        config_characterization_file = self.config_characterization_folder
        self.characterization_folder = os.path.join(config_characterization_file["pre"],
                                                    instrument_short_name,
                                                    config_characterization_file["post"])

    # def init_master_table(self):
    #     o_table = TableInitialization(parent=self)
    #     #o_table.init_master_table()
    #     #o_table.init_signals()
    #     # TODO should load existing json configuration into the table
    #
    #     #self.ui.pushButton_launchReduction.clicked.connect(self.run_mantid)

    def _promote_widgets(self):
        # frame_dockWidget_ipython
        temp_layout = QVBoxLayout()
        self.ui.frame_dockWidget_ipython.setLayout(temp_layout)
        self.ui.dockWidget_ipython = InProcessJupyterConsole(self, startup_code=IPYTHON_STARTUP_CODE)
        temp_layout.addWidget(self.ui.dockWidget_ipython)

    def _init_widgets(self):
        """ Initialize widgets
        Returns
        -------
        """

        #init_size_splitter = self.ui.splitter.size()
        #self.init_size_splitter_height = init_size_splitter.height()
        #init_width = self.size()
        #self.init_width = init_width.width()

        self.ui.splitter.setStyleSheet("""
            QSplitter::handle {
               image: url(':/MPL Toolbar/splitter_icon.png');
            }
            """)


        self.ui.splitter_3.setStyleSheet("""
                    QSplitter::handle {
                       image: url(':/MPL Toolbar/splitter_icon.png');
                    }
                    """)

        self.ui.label_25.setPixmap(QtGui.QPixmap(":/MPL Toolbar/search_icon.png"))
#        self.ui.search_logo_label.setPixmap(QtGui.QPixmap(":/MPL Toolbar/search_icon.png"))
#        self.ui.clear_name_search_2.setIcon(QtGui.QIcon(":/MPL Toolbar/clear_icon.png"))
#        self.ui.clear_search_button.setIcon(QtGui.QIcon(":/MPL Toolbar/clear_icon.png"))

#        self.ui.settings_table_button.setIcon(QtGui.QIcon(":/MPL Toolbar/settings_icon.png"))

        # add the combo box for PDF type
        self.activate_reduction_tabs()

    @property
    def controller(self):
        """
        get handler of controller
        :return:
        """
        return self._myController


    def do_show_help(self):
        """ Show help
        Copied from DGSPlanner
        """
        # close previous service
        self._assistantProcess.close()
        self._assistantProcess.waitForFinished()

        # launch
        # helper_url = QUrl('addie_helper.html')
        helper_url = QUrl('https://neutrons.github.io/addie/index.html')
        QDesktopServices.openUrl(helper_url)

        return

    # Rietveld tab
    def do_load_bragg_file(self):
        rietveld_event_handler.do_load_bragg_file(main_window=self)

    def do_set_bragg_color_marker(self):
        rietveld_event_handler.do_set_bragg_color_marker(self)

    def do_rescale_bragg(self):
        rietveld_event_handler.do_rescale_bragg(self)

    def do_clear_gr(self):
        self.ui.graphicsView_gr.reset()

    def do_clear_sq(self):
        self.ui.graphicsView_sq.reset()

    def evt_change_gss_mode(self):
        rietveld_event_handler.evt_change_gss_mode(main_window=self)

    def evt_plot_bragg_bank(self):
        rietveld_event_handler.plot_bragg_bank(main_window=self)

    def evt_switch_bragg_unit(self):
        rietveld_event_handler.switch_bragg_unit(main_window=self)

    def do_clear_bragg_canvas(self):
        rietveld_event_handler.do_clear_bragg_canvas(self)

    def plot_bragg(self, ws_list, bankIds, clear_canvas=False):
        rietveld_event_handler.plot_bragg_bank(self, ws_list, bankIds, clear_canvas)

    def set_bragg_ws_to_plot(self, gss_group_name):
        rietveld_event_handler.set_bragg_ws_to_plot(self, gss_group_name)

    # G(R) tab

    def do_generate_gr(self):
        calculategr_event_handler.generate_gr_step1(self)

    def evt_qmax_changed(self):
        calculategr_event_handler.evt_qmax_changed(self)

    def evt_qmin_changed(self):
        calculategr_event_handler.evt_qmin_changed(self)

    def do_load_sq(self):
        calculategr_event_handler.load_sq(self)

    def evt_change_sq_type(self):
        calculategr_event_handler.evt_change_sq_type(self)

    def do_rescale_sofq(self):
        calculategr_event_handler.do_rescale_sofq(self)

    def do_rescale_gofr(self):
        calculategr_event_handler.do_rescale_gofr(self)

    def do_show_sq_bound(self):
        calculategr_event_handler.do_show_sq_bound(self)

    def do_load_gr(self):
        calculategr_event_handler.do_load_gr(self)

    def do_save_gr(self):
        calculategr_event_handler.do_save_gr(self)

    def do_save_sq(self):
        calculategr_event_handler.do_save_sq(self)

    def do_edit_sq(self):
        calculategr_event_handler.do_edit_sq(self)

    def do_generate_sq(self):
        calculategr_event_handler.do_generate_sq(self)

    def do_set_gofr_color_marker(self):
        calculategr_event_handler.do_set_gofr_color_marker(self)

    def do_set_sq_color_marker(self):
        calculategr_event_handler.do_set_sq_color_marker(self)

    def do_reset_gr_tab(self):
        calculategr_event_handler.do_reset_gr_tab(self)

    def do_reset_gsas_tab(self):
        calculategr_event_handler.do_reset_gsas_tab(self)




    def clear_bank_checkboxes(self):
        self._noEventBankWidgets = True
        for check_box in list(self._braggBankWidgets.values()):
            check_box.setChecked(False)
        self._noEventBankWidgets = False

        return









    def signal_generate_sq(self, arg_dict):
        """
        signal handling method to generate S(q)
        Note:  https://github.com/neutrons/FastGR/issues/91
        :return:
        """
        # check input
        assert isinstance(arg_dict, dict), 'Input arguments {0} must be given in a dictionary but not a {1}.' \
                                           ''.format(arg_dict, type(arg_dict))

        # determine the selected G(r)
        gr_ws_name_list = self.ui.treeWidget_grWsList.get_workspaces()
        # print '[DB] Selected G(r) workspaces have {0} items.'.format(len(gr_ws_name_list))
        # for gr in gr_ws_name_list:
        #     print '[DB] G(r) {0} of type {1}.'.format(gr, type(gr))

        # check the arguments
        for required_param in ['Qmin', 'Qmax', 'Rmin', 'Rmax', 'DeltaR']:
            if required_param not in list(arg_dict.keys()):
                raise RuntimeError('Not sufficient parameter (missing {0}) to generate S(Q) from G(r).'
                                   ''.format(required_param))

        # TODO/FIXME/FUTURE - Call Mantid algorithm to calculate S(Q)
        raise NotImplementedError('Implement this in future.')

        return





    def edit_sq(self, sq_name, scale_factor, shift):
        """Edit S(Q) in workspace with scale_factor * Y[i] + shift
        :param sq_name:
        :param scale_factor:
        :param shift:
        :return:
        """
        # convert
        sq_name = str(sq_name)

        # check inputs
        assert isinstance(sq_name, str), 'S(Q) workspace name {0} must be a string but not a {1}.' \
                                         ''.format(sq_name, type(sq_name))
        assert isinstance(scale_factor, float), 'Scale factor {0} must be a float but not a {1}.' \
                                                ''.format(scale_factor, type(scale_factor))
        assert isinstance(shift, float), 'Shift {0} must be a float but not a {1}.'.format(shift, type(shift))

        # call the controller
        edit_sq_name = sq_name + '_Edit'
        self._myController.edit_matrix_workspace(sq_name, scale_factor, shift, edit_sq_name)
        # add new S(Q)
        self._pdfColorManager.add_sofq(edit_sq_name)

        color, marker = self.ui.graphicsView_sq.get_plot_info(sq_name)
        print('[DB...BAT] Original SofQ {0} has color {0} marker {1}'.format(color, marker))

        # re-plot
        vec_q, vec_s, vec_e = self._myController.get_sq(edit_sq_name)
        self.ui.graphicsView_sq.plot_sq(edit_sq_name, vec_q, vec_s, vec_e, sq_y_label=sq_name + ' In Edit',
                                        reset_color_mark=False,
                                        color=color, marker=marker)

        # calculate G(r) too
        self.generate_gr([edit_sq_name])

        return

    # def evt_change_sq_type(self):
    #     calculategr_event_handler.evt_change_sq_type(self)
        #
        # """ Event handling to plot S(Q)
        # Returns
        # -------
        #
        # """
        # # get the current S(Q) names
        # curr_sq_list = self.ui.graphicsView_sq.get_shown_sq_names()
        # if len(curr_sq_list) == 0:
        #     return
        #
        # # reset the canvas
        # self.ui.graphicsView_sq.reset()
        #
        # # re-plot
        # for sq_name in curr_sq_list:
        #     # plot S(Q)
        #     self.plot_sq(sq_name, color=None, clear_prev=False)
        #
        # return

    def evt_quit(self):
        """
        Quit the application
        Returns:

        """
        self.close()

    def get_default_data_dir(self):
        """
        Get default data directory
        Returns:
        """
        return self._currDataDir

    def get_workflow(self):
        """
        Return the reference to the main workflow controller
        Returns: workflow controller

        """
        return self._myController

    def process_workspace_change(self, new_ws_list):
        """
        Process (including
        1. add workspace name to tree list and etc) when detecting that
        there is some change to any workspace

        Parameters
        ----------
        new_ws_list :: list of new workspaces' names

        Returns
        -------

        """
        # check input
        assert isinstance(new_ws_list, list), 'Input workspace list must be a list of string' \
            'but not %s.' % str(type(new_ws_list))

        # print 'current tab = ', self.ui.tabWidget_2.currentIndex(), self.ui.tabWidget_2.currentWidget(),
        # print self.ui.tabWidget_2.currentWidget().objectName()
        # print 'current workspaces: ', self._myController.get_current_workspaces()

        # add to tree
        if len(new_ws_list) > 0:
            if self.ui.tabWidget_2.currentWidget().objectName() == 'tab_gR':
                # a new G(r) or S(q)
                for new_ws in new_ws_list:
                    ws_unit = self._myController.get_ws_unit(new_ws)
                    if ws_unit != 'MomentumTransfer':
                        is_gr = True
                    else:
                        # case for SofQ
                        is_gr = False
                        # add to combo box
                        self.ui.comboBox_SofQ.addItem(new_ws)
                        self.ui.treeWidget_grWsList.add_sq(new_ws)
                        # plot generated S(Q)
                        self.plot_sq(sq_ws_name=new_ws, sq_color=None, clear_prev=False)
                    # END-IF
                    self.ui.treeWidget_grWsList.add_arb_gr(new_ws, is_gr)

            elif self.ui.tabWidget_2.currentWidget().objectName() == 'tab_bragg':
                # new Bragg pattern
                for new_ws in new_ws_list:
                    self.ui.treeWidget_braggWSList.add_arb_gr(new_ws)
            # END-IF-ELSE

        return

    def remove_gr_from_plot(self, gr_name):
        """Remove a GofR line from GofR canvas
        :param gr_name: supposed to the G(r) name that is same as workspace name and plot key on canvas as well
        :return:
        """
        # check
        assert isinstance(gr_name, str), 'G(r) plot key {0} must be a string but not a {1}' \
                                         ''.format(gr_name, type(gr_name))

        # remove
        self.ui.graphicsView_gr.remove_gr(plot_key=gr_name)

        return

    def remove_gss_from_plot(self, gss_group_name, gss_bank_ws_name_list):
        """Remove a GSAS group from canvas if they exits
        :param gss_group_name: name of the GSS node, i.e., GSS workspace group's name
        :param gss_bank_ws_name_list: list of names of GSS single banks' workspace name
        :return:
        """
        # check
        assert isinstance(gss_group_name, str), 'GSS group workspace name must be a string but not %s.' \
            '' % str(type(gss_group_name))
        assert isinstance(gss_bank_ws_name_list, list), 'GSAS-single-bank workspace names {0} must be given by ' \
                                                        'list but not {1}.'.format(gss_bank_ws_name_list,
                                                                                   type(gss_bank_ws_name_list))
        if len(gss_bank_ws_name_list) == 0:
            raise RuntimeError('GSAS-single-bank workspace name list is empty!')

        # get bank IDs
        bank_ids = list()
        for gss_bank_ws in gss_bank_ws_name_list:
            bank_id = int(gss_bank_ws.split('_bank')[-1])
            bank_ids.append(bank_id)

        # remove
        self.ui.graphicsView_bragg.remove_gss_banks(gss_group_name, bank_ids)

        # check if there is no such bank's plot on figure, make sure the checkbox is unselected
        # turn on the mutex lock
        self._noEventBankWidgets = True

        for bank_id in range(1, 7):
            has_plot_on_canvas = len(self.ui.graphicsView_bragg.get_ws_name_on_canvas(bank_id)) > 0
            self._braggBankWidgets[bank_id].setChecked(has_plot_on_canvas)

        # turn off the mutex lock
        self._noEventBankWidgets = False

        return

    def remove_sq_from_plot(self, sq_name):
        """
        Remove an SofQ line from SofQ canvas
        Args:
            sq_name: supposed to be the S(Q) name which is same as workspace name and plot key of canvas

        Returns:

        """
        # check
        assert isinstance(sq_name, str)

        # remove
        if self.ui.graphicsView_sq.is_on_canvas(sq_name):
            self.ui.graphicsView_sq.remove_sq(sq_ws_name=sq_name)

        return

    def set_bragg_banks_selected(self, bank_id_list, status):
        """
        set the status of selected bank IDs
        Note: mutex on Bragg Bank selection widgets is not turned on!!!
        Parameters
        ----------
        bank_id_list
        status

        Returns
        -------

        """
        # check inputs
        assert isinstance(bank_id_list, list), 'Bank IDs {0} must be given in a list but not a {1}.' \
                                               ''.format(bank_id_list, type(bank_id_list))
        assert isinstance(status, bool), 'Selection status {0} must be a boolean but not a {1}.' \
                                         ''.format(status, type(status))

        # set
        for bank_id in bank_id_list:
            self._braggBankWidgets[bank_id].setChecked(status)

        return


    def set_ipython_script(self, script):
        """
        Write a command (python script) to ipython console
        Parameters
        ----------
        script

        Returns
        -------

        """
        # check
        assert isinstance(script, str)

        #
        if len(script) == 0:
            # ignore
            return
        else:
            # write to the console
            self.ui.dockWidget_ipython.execute(script)

        return

    def update_sq_boundary(self, boundary_index, new_position):
        """Update the S(Q) range at the main app inputs
        :param boundary_index:
        :param new_position:
        :return:
        """
        # check
        assert isinstance(boundary_index, int), 'Boundary index {0} must be an integer but not {1}.' \
                                                ''.format(boundary_index, type(boundary_index))
        assert isinstance(new_position, float), 'New position {0} must be a float but not {1}.' \
                                                ''.format(new_position, type(new_position))

        # set value
        if boundary_index == 1:
            # left boundary
            self.ui.doubleSpinBoxQmin.setValue(new_position)
        elif boundary_index == 2:
            # right boundary
            self.ui.doubleSpinBoxQmax.setValue(new_position)
        else:
            # exception
            raise RuntimeError('Boundary index %f in method update_sq_boundary() is not '
                               'supported.' % new_position)

        return

    def add_edited_sofq(self, sofq_name, edited_sq_name, shift_value, scale_factor_value):
        """add an edited S(Q) to cached dictionary
        :param sofq_name:
        :param edited_sq_name:
        :param shift_value:
        :param scale_factor_value:
        :return:
        """
        # check
        assert isinstance(sofq_name, str), 'SofQ workspace name {0} must be a string but not a {1}.' \
                                           ''.format(sofq_name, type(sofq_name))
        assert isinstance(edited_sq_name, str), 'Edited S(Q) workspace name {0} must be a string but not a {1}.' \
                                                ''.format(edited_sq_name, type(edited_sq_name))

        # add the entry for the original S(Q) if not done yet
        if sofq_name not in self._editedSofQDict:
            self._editedSofQDict[sofq_name] = dict()

        # add entry
        self._editedSofQDict[sofq_name][shift_value, scale_factor_value] = edited_sq_name

        # add the line and color manager
        self._pdfColorManager.add_sofq(edited_sq_name)

        return

    def has_edit_sofq(self, raw_sofq_name, shift_value, scale_factor_value):
        """ check whether an edited S(Q) has been cached already
        :param raw_sofq_name:
        :param shift_value:
        :param scale_factor_value:
        :return:
        """
        # check
        assert isinstance(raw_sofq_name, str)

        if raw_sofq_name not in self._editedSofQDict:
            return False

        return (shift_value, scale_factor_value) in self._editedSofQDict[raw_sofq_name]

    # menu
    def action_preview_ascii_clicked(self):
        o_gui = Step3GuiHandler(parent=self)
        o_gui.browse_file()

    def action_load_configuration_clicked(self):
        o_import_config = ImportConfiguration(parent=self)
        o_import_config.run()

    def action_save_configuration_clicked(self):
        o_export_config = ExportConfiguration(parent=self)
        o_export_config.run()

    def action_undo_clicked(self):
        o_undo = UndoHandler(parent=self)
        o_undo.undo_table()

    def action_redo_clicked(self):
        o_undo = UndoHandler(parent=self)
        o_undo.redo_table()

    def help_about_clicked(self):
        _about = AboutDialog(parent=self)
        _about.display()

    def advanced_option_clicked(self):
        AdvancedWindowLauncher(parent = self)

    def activate_reduction_tabs(self):
        if self.post_processing == 'idl':
            tab_0 = True
            tab_1 = True
            tab_2 = False
            current_index=0
            visible_menu_configuration = True
        else:
            tab_0 = False
            tab_1 = False
            tab_2 = True
            current_index=2
            visible_menu_configuration = False
        self.ui.main_tab.setTabEnabled(0, tab_0)
        self.ui.main_tab.setTabEnabled(1, tab_1)
        self.ui.main_tab.setTabEnabled(2, tab_2)
        self.setStyleSheet("QTabBar::tab::disabled {width: 0; height: 0; margin: 0; padding: 0; border: none;} ")
        self.ui.main_tab.setCurrentIndex(current_index)

        # also hide the file>configration buttons when working with Mantid
        self.ui.menuLoad_Configuration.menuAction().setVisible(visible_menu_configuration)

    def menu_ipts_file_transfer_clicked(self):
        _o_ipts = IptsFileTransferDialog(parent=self)
        _o_ipts.show()

    def main_tab_widget_changed(self, tab_selected):
        if tab_selected == 0:
            o_gui = Step1GuiHandler(parent=self)
            self.check_step1_gui()
        if tab_selected == 1:
            _o_gui = Step2GuiHandler(parent=self)
            _o_gui.check_gui()

    def window_job_monitor_clicked(self):
        job_handler = JobStatusHandler(parent=self)

    def help_button_clicked(self, button_name='autonom'):
        help_button_activator(parent=self, button_name=button_name)

    # job utility
    def launch_job_manager(self, job_name='', script_to_run=None, thread_index=-1):
        job_handler = JobStatusHandler(parent=self, job_name=job_name,
                                       script_to_run=script_to_run,
                                       thread_index=thread_index)
        job_handler.start()

    def kill_job(self, row=-1):
        job_row = self.job_list[row]
        parent = psutil.Process(job_row['pid'])
        for child in parent.children(recursive=True):
            child.kill()
#	    child.wait()
        parent.kill()

        table_widget = self.job_monitor_interface.ui.tableWidget
        table_widget.removeCellWidget(row, 2)
        _item = QTableWidgetItem('Killed')
        table_widget.setItem(row, 2, _item)
        job_row['status'] = "killed"
        job_row['pid'] = None
        self.job_list[row] = job_row

    def start_refresh_text_thread(self):
        _run_thread = self.logbook_thread
        _run_thread.setup(parent=self)
        _run_thread.update_text.connect(self.update_logbook)
        _run_thread.start()

    def update_logbook(self, text):
        if self.job_monitor_interface is None:
            self.logbook_thread.stop()
        else:
            _logbook_handler = LogbookHandler(parent=self)

    # tab1
    def select_current_folder_clicked(self):
        o_gui = Step1GuiHandler(parent=self)
        o_gui.select_working_folder()
        self.check_step1_gui()

    def diamond_edited(self):
        self.check_step1_gui()

    def diamond_background_edited(self):
        self.check_step1_gui()

    def vanadium_edited(self):
        self.check_step1_gui()

    def vanadium_background_edited(self):
        self.check_step1_gui()

    def sample_background_edited(self):
        self.check_step1_gui()

    def create_new_autonom_folder_button_clicked(self, status):
        o_gui_handler = Step1GuiHandler(parent=self)
        o_gui_handler.new_autonom_group_box(status=status)

    def output_folder_radio_buttons(self):
        o_gui_handler = Step1GuiHandler(parent=self)
        o_gui_handler.manual_output_folder_button_handler()
        o_gui_handler.check_go_button()

    def manual_output_folder_field_edited(self):
        self.check_step1_gui()

    def manual_output_folder_button_clicked(self):
        o_gui = Step1GuiHandler(parent=self)
        o_gui.select_manual_output_folder()
        self.check_step1_gui()

    def run_mantid(self):
        # TODO make a class level name so it can be reused
        filename = os.path.join(os.path.expanduser('~'), '.mantid', 'addie.json')

        # TODO should go to console as well
        print('writing out table to "{}"'.format(filename))
        # maybe this way
        exporter = MantidTableExporter(parent=self, filename=filename)
        exporter.create_dictionary()
        exporter.export()

        # TODO should do the real thing rather than print a message
        # self.launch_job_manager(job_name='mantid', script_to_run=TODO)
        print('supposed to run mantid now')

    def check_step1_gui(self):
        '''check the status of the step1 GUI in order to enable or not the GO BUTTON at the bottom'''
        o_gui_handler = Step1GuiHandler(parent=self)
        o_gui_handler.check_go_button()

    def run_autonom(self):
        """Will first create the output folder, then create the exp.ini file"""
        _run_autonom = RunStep1(parent=self)
        _run_autonom.create_folder()
        print(os.getcwd())
        _run_autonom.create_exp_ini_file()

    def help_button_clicked_autonom(self):
        self.help_button_clicked(button_name='autonom')

    def create_exp_ini_clicked(self):
        _run_autonom = RunStep1(parent=self, run_autonom=False)
        _run_autonom.create_folder()
        _run_autonom.create_exp_ini_file()

    # tab2
    def resize_table_post_processing_tab(self, height, width):
        pass

    def move_to_folder_clicked(self):
        o_load_table = loadTableIntermediateStepInterface(parent=self)
        o_load_table.show()

    def move_to_folder_step2(self):
        if not self.load_intermediate_step_ok:
            return

        o_gui = Step2GuiHandler(parent=self)
        o_gui.move_to_folder()
        self.populate_table_clicked()

    def populate_table_clicked(self):

        self.ui.table.blockSignals(True)

        _pop_table = PopulateMasterTable(parent=self)
        _pop_table.run()
        _error_reported = _pop_table.error_reported

        if _error_reported:
            self.ui.table.blockSignals(False)
            return

        _pop_back_wdg = PopulateBackgroundWidgets(parent=self)
        _pop_back_wdg.run()
        self.name_search_clicked()

        _o_gui = Step2GuiHandler(parent=self)
        _o_gui.check_gui()

        o_undo = UndoHandler(parent=self)
        o_undo.save_table(first_save=True)

        self.ui.table.blockSignals(False)

    def import_table_clicked(self):
        self.ui.table.blockSignals(True)

        _o_table = IdlTableHandler(parent=self)
        _o_table._import()
        self.name_search_clicked()

        o_undo = UndoHandler(parent=self)
        o_undo.save_table(first_save=True)

        self.ui.table.blockSignals(False)

    def export_table_clicked(self):
        _o_table = IdlTableHandler(parent=self)
        _o_table._export()

    def table_select_state_changed(self, state, row):
        _o_table_handler = TableHandler(parent=self)
        _o_table_handler.check_selection_status(state, row)

        _o_gui = Step2GuiHandler(parent=self)
        _o_gui.check_gui()
        _o_gui.define_new_ndabs_output_file_name()
        _o_gui.define_new_sum_scans_output_file_name()

    def name_search_clicked(self):
        o_table = IdlTableHandler(parent=self)
        o_table.name_search()

    def clear_name_search_clicked(self):
        o_table = IdlTableHandler(parent=self)
        self.ui.name_search.setText('')
        o_table.name_search()

    def check_step2_gui(self, row, column):
        _o_gui = Step2GuiHandler(parent=self)
        _o_gui.check_gui()

        _o_gui.step2_background_flag()
        _o_gui.step2_update_background_dropdown()

        if column == 1:
            o_pop = PopulateBackgroundWidgets(parent=self)
            o_pop.refresh_contain()

        o_undo = UndoHandler(parent=self)
        o_undo.save_table()

    # PDF

    def check_q_range(self):
        _o_gui = Step2GuiHandler(parent=self)
        _o_gui.check_gui()

    def hidrogen_clicked(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.hidrogen_clicked()

    def no_hidrogen_clicked(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.no_hidrogen_clicked()

    def yes_background_clicked(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.yes_background_clicked()

    def no_background_clicked(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.no_background_clicked()

    def background_combobox_changed(self, index):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.background_index_changed(row_index=index)

    def reset_q_range(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.reset_q_range()

    def run_ndabs_clicked(self):
        o_create_sample_files = CreateSampleFiles(parent=self)
        o_create_sample_files.run()

        list_sample_files = o_create_sample_files.list_sample_files

        o_create_ndsum_file = CreateNdsumFile(parent=self)
        o_create_ndsum_file.run()

        o_run_ndsum = RunNDabs(parent=self, list_sample_files=list_sample_files)
        o_run_ndsum.run()

    def check_fourier_filter_widgets(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def check_plazcek_widgets(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def table_right_click(self, position):
        _o_table = IdlTableHandler(parent=self)
        _o_table.right_click(position=position)

    def run_sum_scans_clicked(self):
        o_run_sum_scans = RunSumScans(parent=self)
        o_run_sum_scans.run()

    def output_file_name_changed(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def pdf_qmax_line_edit_changed(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def sum_scans_output_file_name_changed(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def help_button_clicked_ndabs(self):
        self.help_button_clicked(button_name='ndabs')

    def help_button_clicked_scans(self):
        self.help_button_clicked(button_name='scans')

    # Rietveld

    def mantid_browse_calibration_clicked(self):
        o_mantid_gui = BrowseFileFolderHandler(parent=self)
        o_mantid_gui.browse_file(type='calibration')

    def mantid_browse_characterization_clicked(self):
        o_mantid_gui = BrowseFileFolderHandler(parent=self)
        o_mantid_gui.browse_file(type='characterization')

    def mantid_output_directory_clicked(self):
        o_mantid_gui = BrowseFileFolderHandler(parent=self)
        o_mantid_gui.browse_folder()

    def do_mantid_run_reduction(self):
        o_mantid_run = GlobalMantidReduction(parent=self)
        o_mantid_run.run()

    def check_mantid_gui(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def help_button_clicked_mantid(self):
        self.help_button_clicked(button_name='mantid')

    # Mantid

    # master table
    def personalization_table_clicked(self):
        _ = TableTreeHandler(parent=self)
        _table_config = TableConfig(main_window=self)
        current_config = _table_config.get_current_config()
        _table_config.update_tree_dict_and_tree(config_to_load=current_config)

    def closeEvent(self, c):
        if self.advanced_window_ui:
            self.advanced_window_ui.closeEvent(c)
        if self.make_calibration_ui:
            self.make_calibration_ui.closeEvent(c)
        if self.table_tree_ui:
            self.table_tree_ui.closeEvent(c)

    # events of the table and the tree

    def table_search(self, text):
        o_table = MtdTableHandler(parent=self)
        o_table.search(text)

    def table_search_clear(self):
        o_table = MtdTableHandler(parent=self)
        o_table.clear_search()

    def load_this_config(self, key='', resize=False):
        if key == '':
            return

        if key == 'FULL_RESET':
            config_to_load = self.reset_config_dict['table']
        else:
            config_to_load = self.config_dict[key]['table']

        h1_dict = config_to_load['h1']
        h2_dict = config_to_load['h2']
        h3_dict = config_to_load['h3']

        o_table = TableConfig(main_window=self)
        o_table.disconnect_table_ui()

        for _col in h1_dict:
            _visible = h1_dict[_col]['visible']
            _width = h1_dict[_col]['width']
            o_table.set_size_and_visibility_column(h1=_col, width=_width, visibility=_visible, resize=resize)

        for _col in h2_dict:
            _visible = h2_dict[_col]['visible']
            _width = h2_dict[_col]['width']
            o_table.set_size_and_visibility_column(h2=_col, width=_width, visibility=_visible, resize=resize)

        for _col in h3_dict:
            _visible = h3_dict[_col]['visible']
            _width = h3_dict[_col]['width']
            o_table.set_size_and_visibility_column(h3=_col, width=_width, visibility=_visible, resize=resize)

        o_table.update_tree_dict_and_tree(config_to_load)

        o_table.disconnect_table_ui(unblock_all=True)

    def h3_table_right_click(self, position):
        o_h3_table = H3TableHandler(main_window=self)
        o_h3_table.right_click()

    def check_status_of_right_click_buttons(self):
        o_h3_table = H3TableHandler(main_window=self)
        o_h3_table.check_status_of_right_click_buttons()

    def scroll_h1_table(self, value):
        self.processing_ui.h2_table.horizontalScrollBar().setValue(value)
        self.processing_ui.h3_table.horizontalScrollBar().setValue(value)

    def scroll_h2_table(self, value):
        self.processing_ui.h1_table.horizontalScrollBar().setValue(value)
        self.processing_ui.h3_table.horizontalScrollBar().setValue(value)

    def scroll_h3_table(self, value):
        self.processing_ui.h1_table.horizontalScrollBar().setValue(value)
        self.processing_ui.h2_table.horizontalScrollBar().setValue(value)

    def resizing_h1(self, index_column, old_size, new_size):

        o_table = TableConfig(main_window=self)
        o_table.disconnect_table_ui()

        h2_children = o_table.get_h2_children_from_h1(h1=index_column)
        last_h2_visible = o_table.get_last_h2_visible(list_h2=h2_children)
        list_h3 = o_table.get_h3_children_from_h2(h2=last_h2_visible)
        last_h3_visible = o_table.get_last_h3_visible(list_h3=list_h3)

        size_diff = new_size - old_size

        # add this size_diff to last_h2 and last_h3
        last_h3_visible_size = o_table.get_size_column(h3=last_h3_visible)
        if (last_h3_visible_size < self.minimum_col_width) and \
                (new_size < old_size):
            o_table.set_size_column(h1=index_column, width=old_size)
        else:
            last_h2_visible_size = o_table.get_size_column(h2=last_h2_visible)
            o_table.set_size_column(h2=last_h2_visible, width=last_h2_visible_size + size_diff)
            o_table.set_size_column(h3=last_h3_visible, width=last_h3_visible_size + size_diff)

        o_table.disconnect_table_ui(unblock_all=True)

    def resizing_h2(self, index_column, old_size, new_size):
        o_table = TableConfig(main_window=self)
        o_table.disconnect_table_ui()

        h1_parent = o_table.get_h1_parent_from_h2(h2=index_column)
        h3_children = o_table.get_h3_children_from_h2(h2=index_column)
        last_h3_visible = o_table.get_last_h3_visible(list_h3=h3_children)

        size_diff = new_size - old_size

        last_h3_visible_size = o_table.get_size_column(h3=last_h3_visible)
        if (last_h3_visible_size < self.minimum_col_width) and \
                (new_size < old_size):
            o_table.set_size_column(h2=index_column, width=old_size)
        else:
            # add this size_diff to parent and last h3
            parent_size = o_table.get_size_column(h1=h1_parent)
            o_table.set_size_column(h1=h1_parent, width=parent_size + size_diff)
            o_table.set_size_column(h3=last_h3_visible, width=last_h3_visible_size + size_diff)

        o_table.disconnect_table_ui(unblock_all=True)

    def resizing_h3(self, index_column, old_size, new_size):

        o_table = TableConfig(main_window=self)
        o_table.disconnect_table_ui()

        [h1_parent, h2_parent] = o_table.get_h1_h2_parent_from_h3(h3=index_column)

        size_diff = new_size - old_size

        h1_parent_size = o_table.get_size_column(h1=h1_parent)
        o_table.set_size_column(h1=h1_parent, width=h1_parent_size + size_diff)
        h2_parent_size = o_table.get_size_column(h2=h2_parent)
        o_table.set_size_column(h2=h2_parent, width=h2_parent_size + size_diff)

        o_table.disconnect_table_ui(unblock_all=True)

    def init_widgets(self):
        pass

    def init_tree(self):
        # fill the self.ui.treeWidget
        # self.addItems(self.ui.treeWidget.invisibleRootItem())
        self.addItems(self.ui.treeWidget.invisibleRootItem())
        self.ui.treeWidget.itemChanged.connect(self.tree_item_changed)

    def tree_item_changed(self, item, _):
        """this will change the way the big table will look like by hidding or showing columns"""

        o_table = TableConfig(main_window=self)
        o_table.block_table_header_ui(block_all=False,
                                      block_h1=True,
                                      block_h2=True)

        h_columns_affected = o_table.get_h_columns_from_item_name(item_name=o_table.get_item_name(item))

        o_table.change_state_tree(list_ui=h_columns_affected['list_tree_ui'],
                                  list_parent_ui=h_columns_affected['list_parent_ui'],
                                  state=item.checkState(0))

        o_table.update_table_columns_visibility()
        o_table.resizing_table(tree_dict=h_columns_affected, block_ui=False)

        o_table.block_table_header_ui(unblock_all=True)

    # widgets from master table
    def master_table_select_state_changed(self, state, key):
        o_table = TableRowHandler(main_window=self)
        o_table.activated_row_changed(key=key, state=state)

    ## sample columns
    def master_table_sample_material_button_pressed(self, key):
        MaterialHandler(parent=self, key=key, data_type='sample')

    def master_table_sample_material_line_edit_entered(self, key):
        o_table = TableRowHandler(main_window=self)
        o_table.transfer_widget_states(from_key=key, data_type='sample')

    def master_table_sample_mass_density_button_pressed(self, key):
        MassDensityHandler(parent=self, data_type='sample', key=key)

    def master_table_sample_mass_density_line_edit_entered(self, key):
        o_table = TableRowHandler(main_window=self)
        o_table.transfer_widget_states(from_key=key, data_type='sample')

    def master_table_sample_shape_changed(self, index, key):
        o_table = TableRowHandler(main_window=self)
        o_table.shape_changed(shape_index=index, key=key, data_type='sample')

    def master_table_sample_abs_correction_changed(self, text, key):
        o_table = TableRowHandler(main_window=self)
        o_table.abs_correction_changed(value=text, key=key, data_type='sample')

    def master_table_sample_multi_scattering_correction_changed(self, text, key):
        o_table = TableRowHandler(main_window=self)
        o_table.multi_scattering_correction(value=text, key=key, data_type='sample')

    def master_table_sample_inelastic_correction_changed(self, text, key):
        o_table = TableRowHandler(main_window=self)
        o_table.inelastic_correction_changed(value=text, key=key, data_type='sample')

    def master_table_sample_placzek_button_pressed(self, key):
        o_table = TableRowHandler(main_window=self)
        o_table.placzek_button_pressed(key=key, data_type='sample')

    def master_table_sample_dimensions_setter_button_pressed(self, key):
        o_dimensions_ui = DimensionsSetter(parent=self, key=key, data_type='sample')
        o_dimensions_ui.show()

    # normalization columns
    def master_table_normalization_material_button_pressed(self, key):
        MaterialHandler(parent=self, key=key, data_type='normalization')

    def master_table_normalization_material_line_edit_entered(self, key):
        o_table = TableRowHandler(main_window=self)
        o_table.transfer_widget_states(from_key=key, data_type='normalization')

    def master_table_normalization_mass_density_button_pressed(self, key):
        MassDensityHandler(parent=self, data_type='normalization', key=key)

    def master_table_normalization_mass_density_line_edit_entered(self, key):
        o_table = TableRowHandler(main_window=self)
        o_table.transfer_widget_states(from_key=key, data_type='normalization')

    def master_table_normalization_shape_changed(self, text, key):
        o_table = TableRowHandler(main_window=self)
        o_table.shape_changed(shape_index=text, key=key, data_type='normalization')

    def master_table_normalization_abs_correction_changed(self, text, key):
        o_table = TableRowHandler(main_window=self)
        o_table.abs_correction_changed(value=text, key=key, data_type='normalization')

    def master_table_normalization_multi_scattering_correction_changed(self, text, key):
        o_table = TableRowHandler(main_window=self)
        o_table.multi_scattering_correction(value=text, key=key, data_type='normalization')

    def master_table_normalization_inelastic_correction_changed(self, text, key):
        o_table = TableRowHandler(main_window=self)
        o_table.inelastic_correction_changed(value=text, key=key, data_type='normalization')

    def master_table_normalization_placzek_button_pressed(self, key):
        o_table = TableRowHandler(main_window=self)
        o_table.placzek_button_pressed(key=key, data_type='normalization')

    def master_table_normalization_dimensions_setter_button_pressed(self, key):
        o_dimensions_ui = DimensionsSetter(parent=self, key=key, data_type='normalization')
        o_dimensions_ui.show()

    def launch_import_from_database_handler(self):
        if ONCAT_ENABLED:
            ImportFromDatabaseHandler(parent=self)
        else:
            print('oncat functionality disabled')

    def launch_import_from_run_number_handler(self):
        ImportFromRunNumberHandler(parent=self)

    # def master_table_input_grouping_button_pressed(self, key):
    #     o_table = TableRowHandler(parent=self)
    #     o_table.grouping_button(key=key, grouping_type='input')
    #
    # def master_table_output_grouping_button_pressed(self, key):
    #     o_table = TableRowHandler(parent=self)
    #     o_table.grouping_button(key=key, grouping_type='output')

    # calibrations
    def make_calibration_clicked(self):
        MakeCalibrationLauncher(parent=self)

    def browse_calibration_clicked(self):
        _calibration_folder = self.calibration_folder
        [_calibration_file, _] = QFileDialog.getOpenFileName(parent = self,
                                                             caption = "Select Calibration File",
                                                             directory = _calibration_folder,
                                                             filter = self.calibration_extension)
        if _calibration_file:
            self.processing_ui.calibration_file.setText(_calibration_file)

    def from_oncat_to_master_table(self, json=None, with_conflict=False, ignore_conflicts=False):
        if self.import_from_database_ui:
            self.import_from_database_ui.close()

        LoadIntoMasterTable(parent=self, json=json,
                            with_conflict=with_conflict,
                            ignore_conflicts=ignore_conflicts)

    def apply_clicked(self):
        # do stuff
        self.close()

    def cancel_clicked(self):
        self.close()

    def _load_ascii(self, filename=''):
        o_ascii_loader = AsciiLoader(parent=self, filename=filename)
        o_ascii_loader.load()

    def reduction_configuration_button_clicked(self):
        ReductionConfigurationHandler(parent=self)


def main(mode):
    app = QApplication(sys.argv)
    app.setOrganizationName("Qtrac Ltd.")
    app.setOrganizationDomain("qtrac.eu")
    app.setApplicationName("Image Changer")
    app.setWindowIcon(QIcon(":/icon.png"))
    form = MainWindow(processing_mode=mode)
    form.show()
    app.exec_()


if __name__ == '__main__':
    import argparse  # noqa
    parser = argparse.ArgumentParser(description='ADvanced DIffraction Environment')
    parser.add_argument('--version', action='version', version='%(prog)s version {}'.format(__version__))
    parser.add_argument('--mode', type=str, default='mantid',
                        help='Set processing mode (default=%(default)s)', choices=['mantid', 'idl'])

    try:  # set up bash completion as a soft dependency
        import argcomplete  # noqa
        argcomplete.autocomplete(parser)
    except ImportError:
        pass  # silently skip this

    # parse the command line options
    options = parser.parse_args()

    # start the main program
    main(options.mode)
